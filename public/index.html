<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Claude View</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  :root {
    --bg: #0f1117;
    --surface: #1a1d27;
    --surface2: #242836;
    --text: #e2e4ea;
    --text-dim: #6b7084;
    --accent: #8b5cf6;
    --green: #34d399;
    --amber: #fbbf24;
    --red: #f87171;
    --blue: #60a5fa;
    --user-green: #065f46;
    --idle-yellow: #78350f;
  }
  html, body {
    height: 100%; overflow: hidden;
    background: var(--bg); color: var(--text);
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, sans-serif;
    font-size: 15px;
  }
  #app { display: flex; flex-direction: column; height: 100%; }

  /* Top bar */
  #topbar {
    background: var(--surface); padding: 12px 16px;
    display: flex; align-items: center; gap: 10px;
    border-bottom: 1px solid #ffffff0a;
    flex-shrink: 0;
  }
  #conn-dot {
    width: 10px; height: 10px; border-radius: 50%;
    background: var(--red); flex-shrink: 0;
    transition: background 0.3s;
  }
  #conn-dot.connected { background: var(--green); }
  #topbar-title { font-weight: 600; font-size: 16px; }
  #topbar-branch {
    font-size: 11px; color: var(--text-dim); background: var(--surface2);
    padding: 2px 8px; border-radius: 8px; flex-shrink: 0;
  }
  #topbar-branch:empty { display: none; }
  #topbar-status {
    margin-left: auto; font-size: 13px; color: var(--text-dim);
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    max-width: 50%;
  }

  /* Session bar */
  #session-bar {
    display: none; background: var(--surface);
    border-bottom: 1px solid #ffffff0a; flex-shrink: 0;
    overflow-x: auto; white-space: nowrap; padding: 6px 12px;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
  }
  #session-bar::-webkit-scrollbar { display: none; }
  #session-bar.visible { display: flex; gap: 8px; }
  .session-chip {
    display: inline-flex; align-items: center; gap: 4px;
    padding: 5px 12px; border-radius: 16px; font-size: 13px;
    background: var(--surface2); color: var(--text-dim);
    cursor: pointer; border: 1px solid transparent;
    transition: all 0.2s; flex-shrink: 0;
    font-family: inherit;
  }
  .session-chip.active {
    background: var(--accent); color: white; border-color: var(--accent);
  }
  .session-chip:not(.active):active { background: #2e3345; }
  .session-badge {
    display: inline-block; min-width: 16px; height: 16px; line-height: 16px;
    border-radius: 8px; background: var(--red); color: white;
    font-size: 10px; text-align: center; padding: 0 4px;
  }
  .session-badge:empty { display: none; }
  .session-question-dot {
    width: 8px; height: 8px; border-radius: 50%;
    background: var(--amber); display: none;
  }
  .session-chip.has-question .session-question-dot { display: inline-block; }

  /* Message area */
  .msg {
    max-width: 90%; padding: 10px 14px; border-radius: 12px;
    line-height: 1.4; word-break: break-word; animation: fadeIn 0.2s;
  }
  @keyframes fadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: none; } }

  /* Activity: dimmed, left-aligned */
  .msg.activity {
    background: #ffffff06; color: var(--text-dim); font-size: 13px;
    border-radius: 8px; padding: 6px 12px; align-self: flex-start;
  }

  /* Notifications by level */
  .msg.notification { align-self: flex-start; }
  .msg.notification.info { background: #1e293b; border-left: 3px solid var(--blue); }
  .msg.notification.warning { background: #2a2011; border-left: 3px solid var(--amber); }
  .msg.notification.error { background: #2a1215; border-left: 3px solid var(--red); }
  .msg.notification.success { background: #0d2818; border-left: 3px solid var(--green); }

  /* Question: purple card */
  .msg.question {
    background: #1e1338; border: 1px solid #8b5cf680;
    align-self: flex-start; width: 95%;
  }
  .msg.question.answered { opacity: 0.45; border-color: #3a3a4a; }
  .question-text { margin-bottom: 10px; font-weight: 500; }
  .question-options { display: flex; flex-wrap: wrap; gap: 8px; }
  .question-options button {
    background: var(--accent); color: white; border: none;
    padding: 8px 16px; border-radius: 20px; font-size: 14px;
    cursor: pointer; transition: background 0.15s;
    font-family: inherit;
  }
  .question-options button:active { background: #7c3aed; }
  .question-options button:disabled { opacity: 0.4; cursor: default; }

  /* User messages: right-aligned */
  .msg.user {
    background: var(--user-green); align-self: flex-end;
    border-radius: 12px 12px 4px 12px;
  }

  /* Status updates */
  .msg.status {
    background: transparent; color: var(--text-dim);
    font-size: 12px; text-align: center; align-self: center;
    padding: 4px 12px;
  }

  /* Idle prompt */
  .msg.idle {
    background: #2a2011; border: 1px solid var(--amber);
    align-self: center; text-align: center; font-size: 14px;
  }

  /* Formatted text */
  .msg code {
    background: #00000040; padding: 1px 5px; border-radius: 4px;
    font-family: "SF Mono", "Fira Code", monospace; font-size: 13px;
  }
  .msg strong { font-weight: 600; }

  /* Tabs */
  #tabs {
    display: flex; background: var(--surface);
    border-bottom: 1px solid #ffffff0a; flex-shrink: 0;
  }
  .tab {
    flex: 1; padding: 8px 0; text-align: center; font-size: 13px;
    font-weight: 500; color: var(--text-dim); cursor: pointer;
    border-bottom: 2px solid transparent; transition: all 0.2s;
    background: none; border-top: none; border-left: none; border-right: none;
    font-family: inherit;
  }
  .tab.active { color: var(--accent); border-bottom-color: var(--accent); }
  .tab-badge {
    display: inline-block; min-width: 16px; height: 16px; line-height: 16px;
    border-radius: 8px; background: var(--accent); color: white;
    font-size: 10px; text-align: center; margin-left: 4px; padding: 0 4px;
  }

  /* Message panels */
  .msg-panel { flex: 1; overflow-y: auto; padding: 12px 16px;
    display: none; flex-direction: column; gap: 8px;
    -webkit-overflow-scrolling: touch;
  }
  .msg-panel.active { display: flex; }

  /* Timestamp */
  .msg-time { font-size: 11px; color: var(--text-dim); margin-top: 4px; }

  /* Notification permission banner */
  #notif-banner {
    background: var(--surface2); padding: 8px 16px;
    display: none; align-items: center; justify-content: space-between;
    font-size: 13px; flex-shrink: 0;
  }
  #notif-banner button {
    background: var(--accent); color: white; border: none;
    padding: 4px 12px; border-radius: 12px; font-size: 12px; cursor: pointer;
  }
  #notif-banner .dismiss {
    background: none; color: var(--text-dim); padding: 4px 8px;
  }

  /* Input bar */
  #inputbar {
    background: var(--surface); padding: 10px 12px;
    display: flex; gap: 8px; align-items: center;
    border-top: 1px solid #ffffff0a;
    flex-shrink: 0;
    padding-bottom: max(10px, env(safe-area-inset-bottom));
  }
  #input {
    flex: 1; background: var(--bg); color: var(--text);
    border: 1px solid #ffffff15; border-radius: 22px;
    padding: 10px 16px; font-size: 15px; outline: none;
    font-family: inherit;
  }
  #input:focus { border-color: var(--accent); }
  #send-btn {
    background: var(--accent); color: white; border: none;
    width: 42px; height: 42px; border-radius: 50%;
    font-size: 20px; cursor: pointer; flex-shrink: 0;
    display: flex; align-items: center; justify-content: center;
  }
  #send-btn:active { background: #7c3aed; }
</style>
</head>
<body>
<div id="app">
  <div id="topbar">
    <div id="conn-dot"></div>
    <div id="topbar-title">Claude View</div>
    <div id="topbar-branch"></div>
    <div id="topbar-status"></div>
  </div>
  <div id="session-bar"></div>
  <div id="tabs">
    <button class="tab active" data-tab="chat">Chat</button>
    <button class="tab" data-tab="activity">Activity</button>
  </div>
  <div id="notif-banner">
    <span>Enable push notifications?</span>
    <span>
      <button id="notif-enable">Enable</button>
      <button class="dismiss" id="notif-dismiss">No</button>
    </span>
  </div>
  <div id="chat-panel" class="msg-panel active"></div>
  <div id="activity-panel" class="msg-panel"></div>
  <div id="inputbar">
    <input id="input" type="text" placeholder="Send instruction..." autocomplete="off" />
    <button id="send-btn">&#9654;</button>
  </div>
</div>

<script src="/socket.io/socket.io.js"></script>
<script>
(function() {
  // Get token from URL hash
  var token = location.hash.slice(1);
  if (!token) {
    var chatP = document.getElementById("chat-panel");
    var warn = document.createElement("div");
    warn.className = "msg notification warning";
    warn.style.marginTop = "40px";
    warn.style.textAlign = "center";
    warn.textContent = "No auth token. Add #TOKEN to the URL.";
    chatP.appendChild(warn);
    return;
  }

  var chatPanel = document.getElementById("chat-panel");
  var activityPanel = document.getElementById("activity-panel");
  var inputEl = document.getElementById("input");
  var sendBtn = document.getElementById("send-btn");
  var connDot = document.getElementById("conn-dot");
  var statusText = document.getElementById("topbar-status");
  var topbarTitle = document.getElementById("topbar-title");
  var topbarBranch = document.getElementById("topbar-branch");
  var sessionBar = document.getElementById("session-bar");
  var tabs = document.querySelectorAll(".tab");
  var notifBanner = document.getElementById("notif-banner");

  var activeTab = "chat";
  var activityCount = 0;
  var titleFlashInterval = null;
  var originalTitle = document.title;

  // --- Multi-session state ---
  var sessionStates = {}; // id -> { store: [], status, meta, unreadCount, hasPendingQuestion, pendingQuestionId, seenIds }
  var activeSessionId = null;
  var sessionOrder = []; // ordered session IDs

  function getOrCreateSessionState(id) {
    if (!sessionStates[id]) {
      sessionStates[id] = {
        store: [],
        status: "",
        meta: {},
        unreadCount: 0,
        hasPendingQuestion: false,
        pendingQuestionId: null,
        seenIds: new Set()
      };
      if (sessionOrder.indexOf(id) === -1) sessionOrder.push(id);
    }
    return sessionStates[id];
  }

  // --- Formatted text rendering (safe DOM only) ---
  function renderFormattedText(container, text) {
    // Split by formatting tokens: **bold**, `code`, and newlines
    var remaining = text;
    while (remaining.length > 0) {
      // Find the earliest match
      var boldIdx = remaining.indexOf("**");
      var codeIdx = remaining.indexOf("`");
      var nlIdx = remaining.indexOf("\n");

      var earliest = remaining.length;
      var type = "none";
      if (boldIdx !== -1 && boldIdx < earliest) { earliest = boldIdx; type = "bold"; }
      if (codeIdx !== -1 && codeIdx < earliest) { earliest = codeIdx; type = "code"; }
      if (nlIdx !== -1 && nlIdx < earliest) { earliest = nlIdx; type = "newline"; }

      // Add text before the match
      if (earliest > 0) {
        container.appendChild(document.createTextNode(remaining.slice(0, earliest)));
      }

      if (type === "none") break;

      if (type === "newline") {
        container.appendChild(document.createElement("br"));
        remaining = remaining.slice(earliest + 1);
      } else if (type === "bold") {
        var endBold = remaining.indexOf("**", earliest + 2);
        if (endBold === -1) {
          // No closing **, treat as text
          container.appendChild(document.createTextNode("**"));
          remaining = remaining.slice(earliest + 2);
        } else {
          var strong = document.createElement("strong");
          strong.textContent = remaining.slice(earliest + 2, endBold);
          container.appendChild(strong);
          remaining = remaining.slice(endBold + 2);
        }
      } else if (type === "code") {
        var endCode = remaining.indexOf("`", earliest + 1);
        if (endCode === -1) {
          container.appendChild(document.createTextNode("`"));
          remaining = remaining.slice(earliest + 1);
        } else {
          var code = document.createElement("code");
          code.textContent = remaining.slice(earliest + 1, endCode);
          container.appendChild(code);
          remaining = remaining.slice(endCode + 1);
        }
      }
    }
  }

  // --- Session bar rendering ---
  function renderSessionBar() {
    sessionBar.textContent = "";
    if (sessionOrder.length <= 1) {
      sessionBar.classList.remove("visible");
      // Still update topbar for single session
      if (sessionOrder.length === 1) {
        var s = sessionStates[sessionOrder[0]];
        if (s && s.meta.repoName) topbarTitle.textContent = s.meta.repoName;
        topbarBranch.textContent = (s && s.meta.branch) || "";
        statusText.textContent = (s && s.status) || "";
      }
      return;
    }
    sessionBar.classList.add("visible");
    sessionOrder.forEach(function(id) {
      var state = sessionStates[id];
      var chip = document.createElement("button");
      chip.className = "session-chip" + (id === activeSessionId ? " active" : "");
      if (state && state.hasPendingQuestion) chip.classList.add("has-question");

      var label = document.createElement("span");
      label.textContent = (state && state.meta.repoName) || id;
      chip.appendChild(label);

      // Question dot
      var dot = document.createElement("span");
      dot.className = "session-question-dot";
      chip.appendChild(dot);

      // Unread badge
      var badge = document.createElement("span");
      badge.className = "session-badge";
      if (state && state.unreadCount > 0 && id !== activeSessionId) {
        badge.textContent = state.unreadCount > 99 ? "99+" : state.unreadCount;
      }
      chip.appendChild(badge);

      chip.addEventListener("click", function() { switchSession(id); });
      sessionBar.appendChild(chip);
    });
  }

  function switchSession(id) {
    if (id === activeSessionId) return;
    activeSessionId = id;
    var state = getOrCreateSessionState(id);
    state.unreadCount = 0;

    // Update topbar
    topbarTitle.textContent = state.meta.repoName || id;
    topbarBranch.textContent = state.meta.branch || "";
    statusText.textContent = state.status || "";

    // Update placeholder
    updatePlaceholder();

    // Re-render panels from session store
    chatPanel.textContent = "";
    activityPanel.textContent = "";
    activityCount = 0;
    var actTab = document.querySelector('.tab[data-tab="activity"]');
    var oldBadge = actTab.querySelector(".tab-badge");
    if (oldBadge) oldBadge.remove();

    state.store.forEach(function(msg) { renderMessageToDOM(msg, state); });
    autoScroll();
    renderSessionBar();
  }

  function updateTopbarForActiveSession() {
    if (!activeSessionId) return;
    var state = sessionStates[activeSessionId];
    if (!state) return;
    topbarTitle.textContent = state.meta.repoName || activeSessionId;
    topbarBranch.textContent = state.meta.branch || "";
    statusText.textContent = state.status || "";
  }

  // Tab switching
  tabs.forEach(function(tab) {
    tab.addEventListener("click", function() {
      activeTab = tab.dataset.tab;
      tabs.forEach(function(t) { t.classList.remove("active"); });
      tab.classList.add("active");
      chatPanel.classList.toggle("active", activeTab === "chat");
      activityPanel.classList.toggle("active", activeTab === "activity");
      if (activeTab === "activity") {
        activityCount = 0;
        var badge = tab.querySelector(".tab-badge");
        if (badge) badge.remove();
        autoScroll();
      }
    });
  });

  function bumpActivityBadge() {
    if (activeTab === "activity") return;
    activityCount++;
    var actTab = document.querySelector('.tab[data-tab="activity"]');
    var badge = actTab.querySelector(".tab-badge");
    if (!badge) {
      badge = document.createElement("span");
      badge.className = "tab-badge";
      actTab.appendChild(badge);
    }
    badge.textContent = activityCount > 99 ? "99+" : activityCount;
  }

  // Push notifications
  var pushEnabled = false;
  if ("Notification" in window && Notification.permission === "default") {
    notifBanner.style.display = "flex";
  }
  document.getElementById("notif-enable").addEventListener("click", function() {
    Notification.requestPermission().then(function(perm) {
      pushEnabled = perm === "granted";
      notifBanner.style.display = "none";
    });
  });
  document.getElementById("notif-dismiss").addEventListener("click", function() {
    notifBanner.style.display = "none";
  });
  if ("Notification" in window && Notification.permission === "granted") {
    pushEnabled = true;
  }
  function sendPushNotification(title, body) {
    if (!pushEnabled || document.hasFocus()) return;
    try { new Notification(title, { body: body, icon: "data:," }); } catch(e) {}
  }

  // Audio context for beeps
  var audioCtx = null;
  function beep() {
    try {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      var osc = audioCtx.createOscillator();
      var gain = audioCtx.createGain();
      osc.connect(gain); gain.connect(audioCtx.destination);
      osc.frequency.value = 660;
      gain.gain.value = 0.3;
      osc.start(); osc.stop(audioCtx.currentTime + 0.15);
      setTimeout(function() {
        var osc2 = audioCtx.createOscillator();
        var gain2 = audioCtx.createGain();
        osc2.connect(gain2); gain2.connect(audioCtx.destination);
        osc2.frequency.value = 880;
        gain2.gain.value = 0.3;
        osc2.start(); osc2.stop(audioCtx.currentTime + 0.15);
      }, 200);
    } catch(e) { /* audio not available */ }
  }

  function flashTitle(text) {
    if (titleFlashInterval) return;
    var on = true;
    titleFlashInterval = setInterval(function() {
      document.title = on ? text : originalTitle;
      on = !on;
    }, 800);
    window.addEventListener("focus", stopFlash, { once: true });
  }
  function stopFlash() {
    if (titleFlashInterval) { clearInterval(titleFlashInterval); titleFlashInterval = null; }
    document.title = originalTitle;
  }

  function formatTime(ts) {
    return new Date(ts).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
  }

  function autoScroll() {
    requestAnimationFrame(function() {
      var panel = activeTab === "chat" ? chatPanel : activityPanel;
      panel.scrollTop = panel.scrollHeight;
    });
  }

  function updatePlaceholder() {
    if (!activeSessionId) {
      inputEl.placeholder = "Send instruction...";
      return;
    }
    var state = sessionStates[activeSessionId];
    inputEl.placeholder = (state && state.hasPendingQuestion)
      ? "Reply to question..."
      : "Send instruction...";
  }

  function createTimeEl(ts) {
    var el = document.createElement("div");
    el.className = "msg-time";
    el.textContent = formatTime(ts);
    return el;
  }

  // Render a message to the DOM (for the active session)
  function renderMessageToDOM(msg, sessionState) {
    var div = document.createElement("div");
    div.dataset.id = msg.id;

    if (msg.type === "activity") {
      div.className = "msg activity";
      div.appendChild(document.createTextNode(msg.summary || (msg.tool + ": (action)")));
      div.appendChild(createTimeEl(msg.ts));
    }
    else if (msg.type === "notification") {
      div.className = "msg notification " + (msg.level || "info");
      var textEl = document.createElement("span");
      renderFormattedText(textEl, msg.message || "");
      div.appendChild(textEl);
      div.appendChild(createTimeEl(msg.ts));
      if (msg.level === "success") sendPushNotification("Task complete", msg.message);
      if (msg.level === "error") sendPushNotification("Error", msg.message);
    }
    else if (msg.type === "question") {
      div.className = "msg question" + (msg.answered ? " answered" : "");

      var qText = document.createElement("div");
      qText.className = "question-text";
      renderFormattedText(qText, msg.question || "");
      div.appendChild(qText);

      if (msg.options && msg.options.length && !msg.answered) {
        var optContainer = document.createElement("div");
        optContainer.className = "question-options";
        msg.options.forEach(function(opt) {
          var btn = document.createElement("button");
          btn.textContent = opt;
          btn.addEventListener("click", function() { respondToQuestion(opt); });
          optContainer.appendChild(btn);
        });
        div.appendChild(optContainer);
      }

      div.appendChild(createTimeEl(msg.ts));

      if (!msg.answered) {
        if (sessionState) {
          sessionState.hasPendingQuestion = true;
          sessionState.pendingQuestionId = msg.id;
        }
        updatePlaceholder();
        beep();
        flashTitle("Question from Claude");
        sendPushNotification("Claude needs you", msg.question);
      }
    }
    else if (msg.type === "user") {
      div.className = "msg user";
      var userText = document.createElement("span");
      renderFormattedText(userText, msg.message || "");
      div.appendChild(userText);
      div.appendChild(createTimeEl(msg.ts));
    }
    else if (msg.type === "status") {
      div.className = "msg status";
      div.textContent = msg.status;
    }
    else if (msg.type === "idle") {
      div.className = "msg idle";
      var idleText = document.createElement("span");
      idleText.textContent = "Claude is idle. Send an instruction to continue.";
      div.appendChild(idleText);
      div.appendChild(createTimeEl(msg.ts));
    }

    chatPanel.appendChild(div);

    // Mirror activity to activity panel
    if (msg.type === "activity") {
      var clone = div.cloneNode(true);
      activityPanel.appendChild(clone);
      bumpActivityBadge();
    }

    autoScroll();
  }

  // Route an incoming message to the correct session
  function routeMessage(msg) {
    var sid = msg.sessionId || "_default";
    var state = getOrCreateSessionState(sid);

    // Deduplicate
    if (state.seenIds.has(msg.id)) return;
    state.seenIds.add(msg.id);
    state.store.push(msg);

    // Auto-select first session
    if (!activeSessionId) {
      activeSessionId = sid;
      updateTopbarForActiveSession();
    }

    if (sid === activeSessionId) {
      // Render to DOM
      renderMessageToDOM(msg, state);
    } else {
      // Increment unread for non-active session
      state.unreadCount++;
      renderSessionBar();
    }

    // Handle question timeout
    if (msg.timedOut && msg.type === "question") {
      state.hasPendingQuestion = false;
      state.pendingQuestionId = null;
      if (sid === activeSessionId) updatePlaceholder();
    }
  }

  // Respond to question
  function respondToQuestion(answer) {
    var sessionParam = activeSessionId ? "?session=" + encodeURIComponent(activeSessionId) : "";
    fetch("/api/respond" + sessionParam, {
      method: "POST",
      headers: { "Content-Type": "application/json", "X-Auth-Token": token },
      body: JSON.stringify({ answer: String(answer) }),
    }).then(function() {
      if (activeSessionId && sessionStates[activeSessionId]) {
        sessionStates[activeSessionId].hasPendingQuestion = false;
        sessionStates[activeSessionId].pendingQuestionId = null;
      }
      updatePlaceholder();
      // Disable buttons on answered questions
      var btns = document.querySelectorAll(".msg.question:not(.answered) button");
      btns.forEach(function(b) { b.disabled = true; });
      var cards = document.querySelectorAll(".msg.question:not(.answered)");
      cards.forEach(function(el) { el.classList.add("answered"); });
      renderSessionBar();
    });
  }
  window.respondToQuestion = respondToQuestion;

  // Send message
  function send() {
    var text = inputEl.value.trim();
    if (!text) return;
    inputEl.value = "";

    var state = activeSessionId ? sessionStates[activeSessionId] : null;
    var sessionParam = activeSessionId ? "?session=" + encodeURIComponent(activeSessionId) : "";

    if (state && state.hasPendingQuestion) {
      respondToQuestion(text);
    } else {
      fetch("/api/send" + sessionParam, {
        method: "POST",
        headers: { "Content-Type": "application/json", "X-Auth-Token": token },
        body: JSON.stringify({ message: text }),
      });
    }
  }

  sendBtn.addEventListener("click", send);
  inputEl.addEventListener("keydown", function(e) {
    if (e.key === "Enter") { e.preventDefault(); send(); }
  });

  // Socket.IO
  var socket = io({ auth: { token: token }, reconnection: true, reconnectionDelay: 1000 });

  socket.on("connect", function() {
    connDot.classList.add("connected");
  });
  socket.on("disconnect", function() {
    connDot.classList.remove("connected");
  });

  socket.on("init", function(data) {
    // Server sends { sessions: [...] }
    chatPanel.textContent = "";
    activityPanel.textContent = "";
    activityCount = 0;
    sessionStates = {};
    sessionOrder = [];
    activeSessionId = null;

    if (data.sessions && data.sessions.length > 0) {
      data.sessions.forEach(function(s) {
        var state = getOrCreateSessionState(s.id);
        state.meta = s.meta || {};
        state.status = s.status || "";
        state.hasPendingQuestion = s.hasPendingQuestion || false;
      });
      // Auto-select first session
      activeSessionId = sessionOrder[0];
      // Fetch messages for active session
      fetchSessionState(activeSessionId);
    }

    renderSessionBar();
    updateTopbarForActiveSession();
    updatePlaceholder();
  });

  function fetchSessionState(sid) {
    fetch("/api/state?session=" + encodeURIComponent(sid) + "&token=" + encodeURIComponent(token))
      .then(function(r) { return r.json(); })
      .then(function(data) {
        var state = getOrCreateSessionState(sid);
        state.hasPendingQuestion = data.hasPendingQuestion;
        state.pendingQuestionId = data.pendingQuestionId;
        if (data.status) state.status = data.status;

        if (sid === activeSessionId) {
          chatPanel.textContent = "";
          activityPanel.textContent = "";
          if (data.status) statusText.textContent = data.status;
          updatePlaceholder();
        }

        data.messages.forEach(function(msg) {
          if (state.seenIds.has(msg.id)) return;
          state.seenIds.add(msg.id);
          state.store.push(msg);
          if (sid === activeSessionId) renderMessageToDOM(msg, state);
        });
        autoScroll();
      });
  }

  socket.on("message", function(msg) {
    routeMessage(msg);
  });

  socket.on("session-status", function(data) {
    var state = sessionStates[data.sessionId];
    if (state) state.status = data.status;
    if (data.sessionId === activeSessionId) {
      statusText.textContent = data.status;
    }
  });

  socket.on("sessions-changed", function(sessionList) {
    sessionList.forEach(function(s) {
      var state = getOrCreateSessionState(s.id);
      state.meta = s.meta || {};
      state.status = s.status || "";
      state.hasPendingQuestion = s.hasPendingQuestion || false;
    });
    // Auto-select if none selected
    if (!activeSessionId && sessionOrder.length > 0) {
      activeSessionId = sessionOrder[0];
      fetchSessionState(activeSessionId);
      updateTopbarForActiveSession();
      updatePlaceholder();
    }
    renderSessionBar();
    updateTopbarForActiveSession();
  });
})();
</script>
</body>
</html>
